package main

import (
	"bytes"
	"crypto/sha256"
	"encoding/hex"
	"errors"
	"io"
	"os"
	"time"
)

func testAlgo() error {
	var cipherText = []byte{
		0xd, 0xb, 0x3, 0x7, 0xe, 0x0, 0xe, 0x2,
		0x6, 0x6, 0x9, 0x0, 0x3, 0xc, 0x8, 0x3,
		0x0, 0xd, 0x4, 0x6, 0x6, 0x4, 0x4, 0xc,
		0x1, 0xf, 0x9, 0xa, 0x0, 0x8, 0x9, 0xc,
		0xa, 0x0, 0xf, 0x8, 0x3, 0x0, 0x6, 0x2,
		0x4, 0x3, 0x0, 0xe, 0x3, 0x2, 0x7, 0xe,
		0xc, 0x8, 0x2, 0x4, 0xe, 0xf, 0xb, 0x8,
		0xb, 0xd, 0x4, 0xf, 0xd, 0xb, 0x0, 0x5,
	}
	var plainText = []byte{
		0x9, 0x2, 0xd, 0xe, 0xf, 0x0, 0x6, 0xb,
		0x3, 0xc, 0x1, 0x3, 0x0, 0xa, 0x5, 0x9,
		0xd, 0xb, 0x5, 0x4, 0xc, 0x7, 0x0, 0x4,
		0xf, 0x8, 0x1, 0x8, 0x9, 0xd, 0x2, 0x0,
		0x4, 0xa, 0x9, 0x8, 0xf, 0xb, 0x2, 0xe,
		0x6, 0x7, 0xa, 0x8, 0x0, 0x2, 0x4, 0xc,
		0x8, 0x9, 0x1, 0x2, 0x4, 0x0, 0x9, 0xb,
		0x1, 0x7, 0xb, 0x5, 0x7, 0xe, 0x4, 0x1,
	}
	var IV = []byte{
		0x12, 0x34, 0x56, 0x78,
		0x90, 0xab, 0xcd, 0xef,
		0x23, 0x45, 0x67, 0x89,
		0x0a, 0xbc, 0xde, 0xf1,
	}
	var key = []byte{
		0xff, 0xee, 0xdd, 0xcc,
		0xbb, 0xaa, 0x99, 0x88,
		0x77, 0x66, 0x55, 0x44,
		0x33, 0x22, 0x11, 0x00,
		0xf0, 0xf1, 0xf2, 0xf3,
		0xf4, 0xf5, 0xf6, 0xf7,
		0xf8, 0xf9, 0xfa, 0xfb,
		0xfc, 0xfd, 0xfe, 0xff,
	}
	t2 := make([]byte, len(IV)*2)
	for i, b := range IV {
		t2[i*2] = (b >> 4) & 0x0F
		t2[i*2+1] = b & 0x0F
	}

	t3 := make([]byte, len(key)*2)
	for i, b := range key {
		t3[i*2] = (b >> 4) & 0x0F
		t3[i*2+1] = b & 0x0F
	}

	cipher := magic(plainText, t2, t3)

	t3 = make([]byte, len(key)*2)
	for i, b := range key {
		t3[i*2] = (b >> 4) & 0x0F
		t3[i*2+1] = b & 0x0F
	}
	plain := magic(cipher, t2, t3)

	if !bytes.Equal(cipher, cipherText) {
		return errors.New("ошибка при проверке шифрования")
	}
	if !bytes.Equal(plain, plainText) {
		return errors.New("ошибка при проверке расшифрования")
	}

	return nil
}

func checkSumm(conf Config) error {
	expectedHash := conf.Hash
	exePath, err := os.Executable()
	if err != nil {
		return errors.New("не удалось получить путь к исполняемому файлу")
	}
	f, err := os.Open(exePath)
	if err != nil {
		return errors.New("не удалось открыть файл")
	}
	defer f.Close()

	h := sha256.New()

	if _, err := io.Copy(h, f); err != nil {
		return errors.New("ошибка чтения файла")
	}
	actualHash := h.Sum(nil)

	if !(hex.EncodeToString(actualHash) == expectedHash) {
		return errors.New("контроль целостности не пройден")
	}

	return nil
}

func testDate(conf Config) error {
	if conf.TimeLimit.Before(time.Now()) {
		return errors.New("время работы СКЗИ (ключа СКЗИ) истекло, обратитесь к администратору")
	}
	return nil
}
